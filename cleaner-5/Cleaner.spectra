import "./imports/DwyerPatternsNamed.spectra"
spec Cleaner

define Dim := 8;
define robot_at_origin := at_origin(robotX, robotY);
define at_target := robotX = target[0] & robotY = target[1];

type Rotation = {DEG_0, DEG_90, DEG_180, DEG_270};
type Coord = Int(0..(Dim - 1));
 
sys Coord robotX;
sys Coord robotY;

// Environment variable which indicates if a target should be cleaned
// In case cleaning_request = false ignore target variable
env boolean cleaning_request;
env Coord[2] target;

env boolean greenLight;
		
// *********************************************
// ***      General Task Requirements        ***
// *********************************************

// If there is a cleaning request from a target, the robot should eventually visit it
gar trig [true]*[cleaning_request & !at_target] |=> [!at_target]*[at_target];

// A cleaning target can be any cell that is not (0,0) and not an obstacle
asm alw !on_obstacle(target[0], target[1]) & !at_origin(target[0], target[1]);

// As long as the robot hasn't reached the target, target's location is not changed and cleaning request remains true
// If left condition doesn't hold, the value of cleaning request is determined (randomly) by the environment
asm alw cleaning_request & !at_target -> fixed_inplace(target[0], target[1]) & next(cleaning_request);

// Fix the initial location of the robot at (0,0)
gar ini robot_at_origin;

// Make sure robot doesn't walk over obstacles
gar alw !on_obstacle(robotX, robotY);	
	 
// The robot can move to adjacent cells horizontally or vertically, but not diagonally
gar alw move_vertically() | move_horizontally() | stay();
	
// *********************************************
// ***          Property #1                  ***
// *********************************************

sys Rotation robot_rotation;

// When the robot reaches the orange zone, it starts its rotation from 0 degrees
gar alw !at_orange_zone() & next(at_orange_zone()) -> next(robot_rotation) = DEG_0;

// Whenever the robot reaches the orange zone, it repeatedly switches its usual appearance
// Its appearance rotates 90 degrees to the right at each step, until it leaves the orange zone
gar alw at_orange_zone() & next(at_orange_zone()) & robot_rotation = DEG_0 -> next(robot_rotation) = DEG_90;
gar alw at_orange_zone() & next(at_orange_zone()) & robot_rotation = DEG_90 -> next(robot_rotation) = DEG_180;
gar alw at_orange_zone() & next(at_orange_zone()) & robot_rotation = DEG_180 -> next(robot_rotation) = DEG_270;
gar alw at_orange_zone() & next(at_orange_zone()) & robot_rotation = DEG_270 -> next(robot_rotation) = DEG_0;

predicate at_orange_zone():
	(robotX >= 1 & robotX <= 5) & (robotY = 0 | robotY = 2 | robotY = 3 | robotY = 5 | robotY = 6);

// *********************************************
// ***          Property #2                  ***
// *********************************************

// Represents the number of consecutive states the robot has been on the orange zone
// orange_steps = 7 -> the robot spent 5 consecutive states in the orange zone and waited 2 steps in place
// and is now waiting for green light to turn on
sys Int(0..7) orange_steps;

// Counter resets when the robot is out of the orange zone
gar alw orange_steps != 0 <-> at_orange_zone();

// If robot has been at the orange zone for 5 or 6 consecutive states then it should stay in place in the next state
gar alw orange_steps = 5 | orange_steps = 6 -> stay();

// If orange_steps < 7 than in the next state it would be incremented (in case robot steps inside the orange zone)
// or set to 0 (in case robot steps outside of the orange zone)
gar alw orange_steps < 7 -> next(orange_steps) = orange_steps + 1 | next(orange_steps) = 0;

// If orange_steps = 7 and there isn't a green light then it should not change and the robot should stay in place
gar alw orange_steps = 7 & !greenLight -> next(orange_steps) = 7 & stay();

// If orange_steps = 7 and there is a green light then orange_steps should be reseted and the robot can 
// start moving again (if robot moves out of the orange zone orange_steps is set to 0 and otherwise to 1)
gar alw orange_steps = 7 & greenLight -> next(orange_steps) = 0 | next(orange_steps) = 1;

// *********************************************
// ***          Property #6                  ***
// *********************************************

asm alwEv greenLight;

// The robot should stay at origin in the first 8 states of its execution
// Then it should start moving only when there is green light
gar alw next(robot_at_origin) | ONCE(initial_wait_count = 8 and greenLight);

counter initial_wait_count (0..8) {
	initial_wait_count = 0;
	inc: true;
	overflow: keep;
}

// *********************************************
// ***          Predicates                  ***
// *********************************************
predicate on_obstacle(Coord x, Coord y):
	(x = 1 & y = 1) | (x = 2 & y = 1) | (x = 3 & y = 1) | (x = 4 & y = 1) | (x = 5 & y = 1) | 
	(x = 1 & y = 4) | (x = 2 & y = 4) | (x = 3 & y = 4) | (x = 4 & y = 4) | (x = 5 & y = 4) |
	(x = 1 & y = 7) | (x = 4 & y = 7);

predicate at_origin(Coord x, Coord y):
	x = 0 & y = 0;

predicate fixed_inplace(Coord x, Coord y):
	x = next(x) & y = next(y);
	
predicate move_vertically():
	(next(robotY) = robotY - 1 | next(robotY) = robotY + 1) & next(robotX) = robotX;
	
predicate move_horizontally():
	(next(robotX) = robotX - 1 | next(robotX) = robotX + 1) & next(robotY) = robotY;

predicate stay():
	fixed_inplace(robotX, robotY);