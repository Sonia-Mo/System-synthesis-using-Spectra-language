import "./imports/DwyerPatternsNamed.spectra"
spec Cleaner

define Dim := 8;
define robot_at_origin := at_origin(robotX, robotY);
define at_target := robotX = target[0] & robotY = target[1];

type Rotation = {DEG_0, DEG_90, DEG_180, DEG_270};
type Coord = Int(0..(Dim - 1));
 
sys Coord robotX;
sys Coord robotY;

// Environment variable which indicates if a target should be cleaned
// In case cleaning_request = false ignore target variable
env boolean cleaning_request;
env Coord[2] target;

env boolean greenLight;
		
// *********************************************
// ***      General Task Requirements        ***
// *********************************************

// If there is a cleaning request from a target, the robot should eventually visit it
gar trig [true]*[cleaning_request & !at_target] |=> [!at_target]*[at_target];

// A cleaning target can be any cell that is not (0,0) and not an obstacle
asm alw !on_obstacle(target[0], target[1]) & !at_origin(target[0], target[1]);

// As long as the robot hasn't reached the target, target's location is not changed and cleaning request remains true
// If left condition doesn't hold, the value of cleaning request is determined (randomly) by the environment
asm alw cleaning_request & !at_target -> fixed_inplace(target[0], target[1]) & next(cleaning_request);

// Fix the initial location of the robot at (0,0)
gar ini robot_at_origin;

// Make sure robot doesn't walk over obstacles
gar alw !on_obstacle(robotX, robotY);	
	 
// The robot can move to adjacent cells horizontally or vertically, but not diagonally
gar alw move_vertically() | move_horizontally() | stay();
	
// *********************************************
// ***          Property #1                  ***
// *********************************************

sys Rotation robot_rotation;

// When the robot reaches the orange zone, it starts its rotation from 0 degrees
gar alw !at_orange_zone() & next(at_orange_zone()) -> next(robot_rotation) = DEG_0;

// Whenever the robot reaches the orange zone, it repeatedly switches its usual appearance
// Its appearance rotates 90 degrees to the right at each step, until it leaves the orange zone
gar alw at_orange_zone() & next(at_orange_zone()) & robot_rotation = DEG_0 -> next(robot_rotation) = DEG_90;
gar alw at_orange_zone() & next(at_orange_zone()) & robot_rotation = DEG_90 -> next(robot_rotation) = DEG_180;
gar alw at_orange_zone() & next(at_orange_zone()) & robot_rotation = DEG_180 -> next(robot_rotation) = DEG_270;
gar alw at_orange_zone() & next(at_orange_zone()) & robot_rotation = DEG_270 -> next(robot_rotation) = DEG_0;

predicate at_orange_zone():
	(robotX >= 1 & robotX <= 5) & (robotY = 0 | robotY = 2 | robotY = 3 | robotY = 5 | robotY = 6);

// *********************************************
// ***          Property #2                  ***
// *********************************************
//TODO: Implement
// *********************************************
// ***          Property #6                  ***
// *********************************************

asm alwEv greenLight;

gar alw waiting_steps < 8 -> robot_at_origin;
gar alw HISTORICALLY(waiting_steps < 8 | waiting_steps = 8 & !greenLight) & next(robot_at_origin) |
		ONCE(waiting_steps = 8 & greenLight);
		
counter waiting_steps (0..8) {
	waiting_steps = 0;
	inc: true;
	overflow: keep;
}

// *********************************************
// ***          Predicates                  ***
// *********************************************
predicate on_obstacle(Coord x, Coord y):
	(x = 1 & y = 1) | (x = 2 & y = 1) | (x = 3 & y = 1) | (x = 4 & y = 1) | (x = 5 & y = 1) | 
	(x = 1 & y = 4) | (x = 2 & y = 4) | (x = 3 & y = 4) | (x = 4 & y = 4) | (x = 5 & y = 4) |
	(x = 1 & y = 7) | (x = 4 & y = 7);

predicate at_origin(Coord x, Coord y):
	x = 0 & y = 0;

predicate fixed_inplace(Coord x, Coord y):
	x = next(x) & y = next(y);
	
predicate move_vertically():
	(next(robotY) = robotY - 1 | next(robotY) = robotY + 1) & next(robotX) = robotX;
	
predicate move_horizontally():
	(next(robotX) = robotX - 1 | next(robotX) = robotX + 1) & next(robotY) = robotY;

predicate stay():
	fixed_inplace(robotX, robotY);