import "./imports/DwyerPatternsNamed.spectra"

spec Robot

// TODO: do we need it?  
//define NumObstacles := 9;		
define Dim := 8;
define Initial_location := robotX = 0 & robotY = 0;
// Define hard-coded obstacles:
define Walk_over_obstacles := (robotX = 5 & robotY = 0) | (robotX = 1 & robotY = 1) | (robotX = 5 & robotY = 1) |
							  (robotX = 3 & robotY = 3) | (robotX = 5 & robotY = 3) | (robotX = 2 & robotY = 5) |
							  (robotX = 5 & robotY = 5) | (robotX = 3 & robotY = 7) | (robotX = 5 & robotY = 7);

type Coord = Int(0..Dim);
type Point = Coord[2];

sys Coord robotX;
sys Coord robotY;

env Point targetA;
env Point targetB;
env Point targetC;

define visit_targetA := robotX = targetA[0] & robotY = targetA[1];
define visit_targetB := robotX = targetB[0] & robotY = targetB[1];
define visit_targetC := robotX = targetC[0] & robotY = targetC[1];

sys boolean was_at_targetA;
sys boolean was_at_targetB;
sys boolean was_at_targetC;

// Assume that targets cannot be at (0,0)
// Assume that target locations never change during a run
asm alw !(targetA[0] = 0 & targetA[1] = 0) & targetA[0] = next(targetA[0]) & targetA[1] = next(targetA[1]);
asm alw !(targetB[0] = 0 & targetB[1] = 0) & targetB[0] = next(targetB[0]) & targetB[1] = next(targetB[1]);
asm alw !(targetC[0] = 0 & targetC[1] = 0) & targetC[0] = next(targetC[0]) & targetC[1] = next(targetC[1]);

// At the initial step, the robot didn't visit any of the targets yet
gar ini !was_at_targetA & !was_at_targetB & !was_at_targetC;
// Fix the initial location of the robot at (0,0)
gar ini Initial_location;

// Move robot by at most 1 step each state: 
gar alw next(robotY) = robotY - 1 &  robotY != 0 | 
		next(robotY) = robotY + 1 &  robotY != Dim | 
		next(robotY) = robotY;	
gar alw next(robotX) = robotX - 1 &  robotX != 0 | 
		next(robotX) = robotX + 1 &  robotX != Dim | 
		next(robotX) = robotX;
		
// Make sure robot doesn't walk over obstacles
gar alw !Walk_over_obstacles;	
	
// Make sure the robot visits the locations an infinite amount of times
gar alwEv was_at_targetA | was_at_targetB | was_at_targetC;

// Turn on the flag in case of a target visit
gar alw visit_targetA implies was_at_targetA;
gar alw visit_targetB implies was_at_targetB;
gar alw visit_targetC implies was_at_targetC;

// Make sure the robot doesn't start a new round before finishing the former
gar alw was_at_targetA implies !next(visit_targetA);
gar alw was_at_targetB implies !next(visit_targetB);
gar alw was_at_targetC implies !next(visit_targetC);

// Make sure the robot is doing an infinite amount of rounds between the targets
gar alwEv !was_at_targetA & !was_at_targetB & !was_at_targetC;

// After the robot has visited all targets, location variables are initialized back to 'false' 
gar alw was_at_targetA & was_at_targetB & was_at_targetC implies !next(was_at_targetA) & !next(was_at_targetB) & !next(was_at_targetC);





		
