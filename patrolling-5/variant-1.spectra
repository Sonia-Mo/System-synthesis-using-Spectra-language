import "./imports/DwyerPatternsNamed.spectra"

spec Robot

// TODO: do we need it?  
//define NumObstacles := 9;		
define Dim := 8;
define Initial_location := robotX = 0 & robotY = 0;
// Define hard-coded obstacles:
define Walk_over_obstacles := (robotX = 5 & robotY = 0) | (robotX = 1 & robotY = 1) | (robotX = 5 & robotY = 1) |
							  (robotX = 3 & robotY = 3) | (robotX = 5 & robotY = 3) | (robotX = 2 & robotY = 5) |
							  (robotX = 5 & robotY = 5) | (robotX = 3 & robotY = 7) | (robotX = 5 & robotY = 7);
// TODO :( :( is there a better way?????
define Target_on_obstacles := (targetA[0] = 5 & targetA[1] = 0) | (targetA[0] = 1 & targetA[1] = 1) | (targetA[0] = 5 & targetA[1] = 1) |
							  (targetA[0] = 3 & targetA[1] = 3) | (targetA[0] = 5 & targetA[1] = 3) | (targetA[0] = 2 & targetA[1] = 5) |
							  (targetA[0] = 5 & targetA[1] = 5) | (targetA[0] = 3 & targetA[1] = 7) | (targetA[0] = 5 & targetA[1] = 7) |
							  (targetB[0] = 5 & targetB[1] = 0) | (targetB[0] = 1 & targetB[1] = 1) | (targetB[0] = 5 & targetB[1] = 1) |
							  (targetB[0] = 3 & targetB[1] = 3) | (targetB[0] = 5 & targetB[1] = 3) | (targetB[0] = 2 & targetB[1] = 5) |
							  (targetB[0] = 5 & targetB[1] = 5) | (targetB[0] = 3 & targetB[1] = 7) | (targetB[0] = 5 & targetB[1] = 7) |
							  (targetC[0] = 5 & targetC[1] = 0) | (targetC[0] = 1 & targetC[1] = 1) | (targetC[0] = 5 & targetC[1] = 1) |
							  (targetC[0] = 3 & targetC[1] = 3) | (targetC[0] = 5 & targetC[1] = 3) | (targetC[0] = 2 & targetC[1] = 5) |
							  (targetC[0] = 5 & targetC[1] = 5) | (targetC[0] = 3 & targetC[1] = 7) | (targetC[0] = 5 & targetC[1] = 7);							  
type Coord = Int(0..Dim);
type Point = Coord[2];

sys Coord robotX;
sys Coord robotY;

env Point targetA;
env Point targetB;
env Point targetC;

define visit_targetA := robotX = targetA[0] & robotY = targetA[1];
define visit_targetB := robotX = targetB[0] & robotY = targetB[1];
define visit_targetC := robotX = targetC[0] & robotY = targetC[1];

sys boolean was_at_targetA;
sys boolean was_at_targetB;
sys boolean was_at_targetC;

// Assume that targets cannot be at (0,0) or on one of the obstacles
asm ini !Target_on_obstacles;
asm alw !(targetA[0] = 0 & targetA[1] = 0);
asm alw !(targetB[0] = 0 & targetB[1] = 0);
asm alw !(targetC[0] = 0 & targetC[1] = 0);

// Assume that target locations never change during a run
asm alw targetA[0] = next(targetA[0]) & targetA[1] = next(targetA[1]);
asm alw targetB[0] = next(targetB[0]) & targetB[1] = next(targetB[1]);
asm alw targetC[0] = next(targetC[0]) & targetC[1] = next(targetC[1]);

// At the initial step, the robot didn't visit any of the targets yet
gar ini !was_at_targetA & !was_at_targetB & !was_at_targetC;
// Fix the initial location of the robot at (0,0)
gar ini Initial_location;

// Move robot by at most 1 step each state: 
gar alw next(robotY) = robotY - 1 &  robotY != 0 | next(robotY) = robotY + 1 &  robotY != Dim | next(robotY) = robotY;	
gar alw next(robotX) = robotX - 1 &  robotX != 0 | next(robotX) = robotX + 1 &  robotX != Dim | next(robotX) = robotX;
		
// Make sure robot doesn't walk over obstacles
gar alw !Walk_over_obstacles;	
	
// Make sure the robot visits the locations an infinite amount of times
// TODO: this way it is realizable, when i change to visit_targetA it stops being realizable
gar alwEv visit_targetA;
gar alwEv visit_targetB;
gar alwEv visit_targetC;

// Turn on the flag in case of a target visit
//gar alw visit_targetA implies (was_at_targetA);
//gar alw visit_targetB implies (was_at_targetB);
//gar alw visit_targetC implies (was_at_targetC);

// Make sure the robot doesn't start a new round before finishing the former
//gar alw was_at_targetA implies !next(visit_targetA);
//gar alw was_at_targetB implies !next(visit_targetB);
//gar alw was_at_targetC implies !next(visit_targetC);

// After the robot has visited all targets, location variables are initialized back to 'false' 
//gar alw was_at_targetA & was_at_targetB & was_at_targetC implies !next(was_at_targetA) & !next(was_at_targetB) & !next(was_at_targetC);





		
