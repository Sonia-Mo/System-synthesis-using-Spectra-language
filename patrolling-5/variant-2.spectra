import "./imports/DwyerPatternsNamed.spectra"

spec Robot
	
define Dim := 5;

type Coord = Int(0..(Dim - 1));
type Point = Coord[2];

sys Coord robotX;
sys Coord robotY;

env Point targetA;
env Point targetB;
env Point targetC;

define at_targetA := robotX = targetA[0] & robotY = targetA[1];
define at_targetB := robotX = targetB[0] & robotY = targetB[1];
define at_targetC := robotX = targetC[0] & robotY = targetC[1];

define robot_at_origin := at_origin(robotX, robotY);

// Assume that targets cannot be at (0,0) or on one of the obstacles
//asm ini !on_obstacle(targetA[0], targetA[1]) &
//		!on_obstacle(targetB[0], targetB[1]) & 
//		!on_obstacle(targetC[0], targetC[1]);
asm ini !at_origin(targetA[0], targetA[1]) & 
		!at_origin(targetB[0], targetB[1]) & 
		!at_origin(targetC[0], targetC[1]);

// Assume that target locations never change during a run
asm alw fixed_inplace(targetA[0], targetA[1]) &
		fixed_inplace(targetB[0], targetB[1]) &
		fixed_inplace(targetC[0], targetC[1]);
		
// Make sure robot doesn't walk over obstacles
//gar alw !on_obstacle(robotX, robotY);	

// Move robot by at most 1 step each state: 
gar alw next(robotY) = robotY - 1 | next(robotY) = robotY + 1 | next(robotY) = robotY;	
gar alw next(robotX) = robotX - 1 | next(robotX) = robotX + 1 | next(robotX) = robotX;

predicate on_obstacle(Coord x, Coord y):
	(x = 1 & y = 1) | (x = 2 & y = 1) | (x = 0 & y = 3) | (x = 3 & y = 3) | (x = 3 & y = 4);

predicate at_origin(Coord x, Coord y):
	x = 0 & y = 0;

predicate fixed_inplace(Coord x, Coord y):
	x = next(x) & y = next(y);
	

// Color of origin	
sys {RED, GREEN} color;

// The progress represent the current targets that were already visited (the order is A->B->C)
sys {A, AB, ABC} progress;

// Fix the initial location of the robot at (0,0)
gar ini robot_at_origin;

// Initial progress is ABC because first target that should be visited is A.
gar ini progress = ABC;

// When finished a round and all targets were visited, the color of origin is turned to RED
gar alw progress = ABC -> color = RED;

// In the middle of a round, the color of origin is GREEN
gar alw !(progress = ABC) -> color = GREEN;

// Cause the robot to complete rounds infinitely
gar alwEv at_targetA;

// Enforce order:
//progress A can change only to AB if target B is visited, or stay A if non target was visited
gar alw progress = A implies (next(progress) = A & !next(at_targetA | at_targetB | at_targetC)) | 
								(next(at_targetB) & next(progress) = AB);
//progress AB can change only to ABC if target C is visited, or stay AB if non target was visited								
gar alw progress = AB implies (next(progress) = AB & !next(at_targetA | at_targetB | at_targetC)) |
								(next(at_targetC) & next(progress) = ABC);
//progress ABC can change only to A if target A is visited, or stay ABC if non target was visited							
gar alw progress = ABC implies (next(progress) = ABC & !next(at_targetA | at_targetB | at_targetC)) |
								(next(at_targetA) & next(progress) = A);
